#!/usr/bin/env python3
"""
Exploit Prevention Test Script
Tests referral system, welcome bonus, and daily cashback for potential exploits.
"""

import asyncio
import sys
import os
import json
from datetime import datetime, timedelta
from unittest.mock import Mock, AsyncMock

# Add the project root to the path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from config.constants import global_data
from utils.user_utils import (
    get_or_create_global_user_data,
    process_referral,
    process_pending_referral,
    process_welcome_bonus
)
from utils.daily_bonus import process_daily_cashback
from config.settings import (
    REFERRAL_BONUS_POINTS,
    WELCOME_BONUS_POINTS,
    DAILY_CASHBACK_PERCENTAGE,
    ALLOWED_GROUP_IDS
)
from config.messages import FALLBACK_USER_NAME
import logging

logger = logging.getLogger(__name__)

class ExploitTestResults:
    def __init__(self):
        self.tests = {
            'referral_exploits': {'passed': 0, 'failed': 0, 'details': []},
            'welcome_bonus_exploits': {'passed': 0, 'failed': 0, 'details': []},
            'daily_cashback_exploits': {'passed': 0, 'failed': 0, 'details': []}
        }
    
    def add_test(self, category, test_name, passed, details=""):
        if passed:
            self.tests[category]['passed'] += 1
            status = "‚úÖ PASS"
        else:
            self.tests[category]['failed'] += 1
            status = "‚ùå FAIL"
        
        self.tests[category]['details'].append(f"{status} {test_name}: {details}")
        print(f"{status} {test_name}: {details}")
    
    def print_summary(self):
        print("\n" + "="*60)
        print("EXPLOIT PREVENTION TEST SUMMARY")
        print("="*60)
        
        total_passed = 0
        total_failed = 0
        
        for category, results in self.tests.items():
            category_name = category.replace('_', ' ').title()
            print(f"\n{category_name}:")
            print(f"  Passed: {results['passed']}")
            print(f"  Failed: {results['failed']}")
            
            for detail in results['details']:
                print(f"  {detail}")
            
            total_passed += results['passed']
            total_failed += results['failed']
        
        print(f"\nOVERALL RESULTS:")
        print(f"Total Passed: {total_passed}")
        print(f"Total Failed: {total_failed}")
        print(f"Success Rate: {(total_passed/(total_passed+total_failed)*100):.1f}%" if (total_passed+total_failed) > 0 else "No tests run")

class ExploitTester:
    def __init__(self):
        self.results = ExploitTestResults()
        self.test_chat_id = -1002780424700  # Use actual chat ID
        self.test_users = {
            'referrer': 999999001,
            'referred_1': 999999002,
            'referred_2': 999999003,
            'self_referrer': 999999004,
            'welcome_user': 999999005,
            'cashback_user': 999999006
        }
        
        # Clear test data
        self.clear_test_data()
    
    def clear_test_data(self):
        """Clear any existing test data"""
        for user_id in self.test_users.values():
            user_id_str = str(user_id)
            if user_id_str in global_data.get("global_user_data", {}):
                del global_data["global_user_data"][user_id_str]
            
            # Clear from chat data
            chat_id_str = str(self.test_chat_id)
            if chat_id_str in global_data.get("all_chat_data", {}):
                if user_id_str in global_data["all_chat_data"][chat_id_str].get("player_stats", {}):
                    del global_data["all_chat_data"][chat_id_str]["player_stats"][user_id_str]
    
    async def test_referral_exploits(self):
        """Test referral system for potential exploits"""
        print("\nüîç Testing Referral System Exploits...")
        
        # Create mock context
        mock_context = Mock()
        mock_context.bot = AsyncMock()
        mock_context.bot.get_chat = AsyncMock()
        
        # Mock user info
        mock_user = Mock()
        mock_user.first_name = "Test"
        mock_user.last_name = "User"
        mock_user.username = "testuser"
        mock_context.bot.get_chat.return_value = mock_user
        
        referrer_id = self.test_users['referrer']
        referred_1_id = self.test_users['referred_1']
        referred_2_id = self.test_users['referred_2']
        self_referrer_id = self.test_users['self_referrer']
        
        # Test 1: Self-referral prevention
        success, message, _ = await process_referral(self_referrer_id, self_referrer_id, mock_context)
        self.results.add_test(
            'referral_exploits',
            'Self-Referral Prevention',
            not success,
            "Self-referral blocked" if not success else "Self-referral allowed (EXPLOIT!)"
        )
        
        # Test 2: Multiple referrals from same user
        # First referral should succeed
        success1, message1, _ = await process_referral(referred_1_id, referrer_id, mock_context)
        self.results.add_test(
            'referral_exploits',
            'First Referral Success',
            success1,
            "First referral processed" if success1 else f"First referral failed: {message1}"
        )
        
        # Second referral from same referrer should succeed (different user)
        success2, message2, _ = await process_referral(referred_2_id, referrer_id, mock_context)
        self.results.add_test(
            'referral_exploits',
            'Multiple Valid Referrals',
            success2,
            "Multiple referrals from same user allowed" if success2 else f"Multiple referrals blocked: {message2}"
        )
        
        # Test 3: Double referral prevention (same user referred twice)
        success3, message3, _ = await process_referral(referred_1_id, referrer_id, mock_context)
        self.results.add_test(
            'referral_exploits',
            'Double Referral Prevention',
            not success3,
            "Double referral blocked" if not success3 else "Double referral allowed (EXPLOIT!)"
        )
        
        # Test 4: Referral points awarding
        initial_points = global_data["global_user_data"].get(str(referrer_id), {}).get("referral_points", 0)
        
        # Process pending referral for first user
        success4, referrer_notified, notification = await process_pending_referral(referred_1_id, mock_context)
        
        final_points = global_data["global_user_data"].get(str(referrer_id), {}).get("referral_points", 0)
        points_awarded = final_points - initial_points
        
        self.results.add_test(
            'referral_exploits',
            'Referral Points Awarding',
            success4 and points_awarded == REFERRAL_BONUS_POINTS,
            f"Awarded {points_awarded} points (expected {REFERRAL_BONUS_POINTS})"
        )
        
        # Test 5: Duplicate referral bonus prevention
        initial_points_2 = final_points
        success5, _, _ = await process_pending_referral(referred_1_id, mock_context)
        final_points_2 = global_data["global_user_data"].get(str(referrer_id), {}).get("referral_points", 0)
        
        self.results.add_test(
            'referral_exploits',
            'Duplicate Referral Bonus Prevention',
            not success5 and final_points_2 == initial_points_2,
            "Duplicate bonus blocked" if not success5 else "Duplicate bonus allowed (EXPLOIT!)"
        )
    
    def test_welcome_bonus_exploits(self):
        """Test welcome bonus system for potential exploits"""
        print("\nüéÅ Testing Welcome Bonus Exploits...")
        
        welcome_user_id = self.test_users['welcome_user']
        
        # Test 1: First welcome bonus
        success1, message1 = process_welcome_bonus(
            welcome_user_id, self.test_chat_id, "Welcome", "User", "welcomeuser"
        )
        
        user_data = global_data["global_user_data"].get(str(welcome_user_id), {})
        bonus_points = user_data.get("bonus_points", 0)
        
        self.results.add_test(
            'welcome_bonus_exploits',
            'First Welcome Bonus',
            success1 and bonus_points == WELCOME_BONUS_POINTS,
            f"Awarded {bonus_points} points" if success1 else f"Failed: {message1}"
        )
        
        # Test 2: Duplicate welcome bonus prevention (same chat)
        initial_bonus = bonus_points
        success2, message2 = process_welcome_bonus(
            welcome_user_id, self.test_chat_id, "Welcome", "User", "welcomeuser"
        )
        
        final_bonus = global_data["global_user_data"].get(str(welcome_user_id), {}).get("bonus_points", 0)
        
        self.results.add_test(
            'welcome_bonus_exploits',
            'Duplicate Welcome Bonus Prevention (Same Chat)',
            not success2 and final_bonus == initial_bonus,
            "Duplicate blocked" if not success2 else "Duplicate allowed (EXPLOIT!)"
        )
        
        # Test 3: Welcome bonus in different chat (should be allowed)
        different_chat_id = -1002780424701  # Different chat
        success3, message3 = process_welcome_bonus(
            welcome_user_id, different_chat_id, "Welcome", "User", "welcomeuser"
        )
        
        final_bonus_diff = global_data["global_user_data"].get(str(welcome_user_id), {}).get("bonus_points", 0)
        
        self.results.add_test(
            'welcome_bonus_exploits',
            'Welcome Bonus Different Chat',
            success3 and final_bonus_diff == (initial_bonus + WELCOME_BONUS_POINTS),
            f"Different chat bonus: {success3}" if success3 else f"Failed: {message3}"
        )
        
        # Test 4: Welcome bonus tracking integrity
        welcome_bonuses = user_data.get("welcome_bonuses_received", {})
        chat1_received = welcome_bonuses.get(str(self.test_chat_id), False)
        chat2_received = welcome_bonuses.get(str(different_chat_id), False)
        
        self.results.add_test(
            'welcome_bonus_exploits',
            'Welcome Bonus Tracking Integrity',
            chat1_received and chat2_received,
            f"Chat tracking: {len(welcome_bonuses)} chats tracked"
        )
    
    async def test_daily_cashback_exploits(self):
        """Test daily cashback system for potential exploits"""
        print("\nüí∞ Testing Daily Cashback Exploits...")
        
        cashback_user_id = self.test_users['cashback_user']
        
        # Create mock context
        mock_context = Mock()
        mock_context.bot = AsyncMock()
        mock_context.bot.send_message = AsyncMock()
        
        # Setup user data
        get_or_create_global_user_data(cashback_user_id, "Cashback", "User", "cashbackuser")
        
        # Setup chat data with player stats
        chat_id_str = str(self.test_chat_id)
        if chat_id_str not in global_data["all_chat_data"]:
            global_data["all_chat_data"][chat_id_str] = {
                "player_stats": {},
                "match_counter": 1,
                "match_history": [],
                "group_admins": [],
                "consecutive_idle_matches": 0
            }
        
        user_id_str = str(cashback_user_id)
        global_data["all_chat_data"][chat_id_str]["player_stats"][user_id_str] = {
            "username": "cashbackuser",
            "score": 1000,
            "total_bets": 0,
            "total_wins": 0,
            "total_losses": 0,
            "last_active": datetime.now().isoformat()
        }
        
        # Create fake match history with losses
        yesterday = datetime.now() - timedelta(days=1)
        yesterday_str = yesterday.strftime("%Y-%m-%d")
        
        # Add match history with losses
        global_data["all_chat_data"][chat_id_str]["match_history"] = [
            {
                "match_id": 1,
                "timestamp": yesterday.isoformat(),
                "result": [3, 4],
                "dice_result": (3, 4),
                "winning_type": "BIG",
                "total_bets": 1000,
                "total_winners": 0,
                "total_losers": 1,
                "total_payout": 0,
                "total_won": 0,
                "total_lost": 1000,
                "losers": [
                    {
                        "user_id": user_id_str,
                        "username": "cashbackuser",
                        "display_name": "Cashback User",
                        "bet_amount": 1000,
                        "wallet_balance": 4000
                    }
                ],
                "winners": []
            }
        ]
        
        # Test 1: First daily cashback
        initial_bonus = global_data["global_user_data"][user_id_str].get("bonus_points", 0)
        
        await process_daily_cashback(mock_context)
        
        final_bonus = global_data["global_user_data"][user_id_str].get("bonus_points", 0)
        expected_cashback = int(1000 * DAILY_CASHBACK_PERCENTAGE)
        actual_cashback = final_bonus - initial_bonus
        
        self.results.add_test(
            'daily_cashback_exploits',
            'Daily Cashback Calculation',
            actual_cashback == expected_cashback,
            f"Cashback: {actual_cashback} (expected: {expected_cashback})"
        )
        
        # Test 2: Duplicate daily cashback prevention
        initial_bonus_2 = final_bonus
        
        await process_daily_cashback(mock_context)
        
        final_bonus_2 = global_data["global_user_data"][user_id_str].get("bonus_points", 0)
        
        self.results.add_test(
            'daily_cashback_exploits',
            'Duplicate Daily Cashback Prevention',
            final_bonus_2 == initial_bonus_2,
            "Duplicate cashback blocked" if final_bonus_2 == initial_bonus_2 else "Duplicate cashback allowed (EXPLOIT!)"
        )
        
        # Test 3: Cashback date tracking
        last_cashback_date = global_data["global_user_data"][user_id_str].get("last_cashback_date")
        today_str = datetime.now().strftime("%Y-%m-%d")
        
        self.results.add_test(
            'daily_cashback_exploits',
            'Cashback Date Tracking',
            last_cashback_date == today_str,
            f"Last cashback date: {last_cashback_date}"
        )
    
    def analyze_current_functionality(self):
        """Analyze and explain current functionality"""
        print("\nüìã CURRENT FUNCTIONALITY ANALYSIS")
        print("="*50)
        
        print("\nüîó REFERRAL SYSTEM:")
        print(f"  ‚Ä¢ Referral bonus: {REFERRAL_BONUS_POINTS} points")
        print("  ‚Ä¢ Two-step process: referral link ‚Üí group join ‚Üí bonus award")
        print("  ‚Ä¢ Prevents self-referrals")
        print("  ‚Ä¢ Prevents duplicate referrals (same user referred twice)")
        print("  ‚Ä¢ Allows multiple referrals from same referrer")
        print("  ‚Ä¢ Points awarded only when referred user joins main group")
        
        print("\nüéÅ WELCOME BONUS SYSTEM:")
        print(f"  ‚Ä¢ Welcome bonus: {WELCOME_BONUS_POINTS} points")
        print("  ‚Ä¢ Per-chat tracking (can receive bonus in different chats)")
        print("  ‚Ä¢ Prevents duplicate bonuses in same chat")
        print("  ‚Ä¢ Added to bonus points (not main wallet)")
        print("  ‚Ä¢ Automatic migration from old single-bonus system")
        
        print("\nüí∞ DAILY CASHBACK SYSTEM:")
        print(f"  ‚Ä¢ Cashback rate: {DAILY_CASHBACK_PERCENTAGE*100}% of previous day losses")
        print("  ‚Ä¢ Processes losses from previous day only")
        print("  ‚Ä¢ Prevents duplicate cashback for same day")
        print("  ‚Ä¢ Added to bonus points (not main wallet)")
        print("  ‚Ä¢ Date tracking prevents exploitation")
        
        print("\nüõ°Ô∏è SECURITY FEATURES:")
        print("  ‚Ä¢ All bonuses go to bonus points (not withdrawable directly)")
        print("  ‚Ä¢ Referral points have usage limits in betting")
        print("  ‚Ä¢ Date-based tracking prevents time manipulation")
        print("  ‚Ä¢ User ID validation prevents impersonation")
        print("  ‚Ä¢ Database synchronization for persistence")
    
    async def run_all_tests(self):
        """Run all exploit tests"""
        print("üîí EXPLOIT PREVENTION TEST SUITE")
        print("="*50)
        
        await self.test_referral_exploits()
        self.test_welcome_bonus_exploits()
        await self.test_daily_cashback_exploits()
        
        self.analyze_current_functionality()
        self.results.print_summary()
        
        # Save test results
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f"test_exploit_prevention_report_{timestamp}.txt"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write("EXPLOIT PREVENTION TEST REPORT\n")
            f.write(f"Generated: {datetime.now().isoformat()}\n")
            f.write("="*60 + "\n\n")
            
            for category, results in self.results.tests.items():
                f.write(f"{category.replace('_', ' ').upper()}:\n")
                f.write(f"Passed: {results['passed']}, Failed: {results['failed']}\n")
                for detail in results['details']:
                    f.write(f"{detail}\n")
                f.write("\n")
        
        print(f"\nüìÑ Test report saved to: {report_file}")

async def main():
    """Main test function"""
    tester = ExploitTester()
    await tester.run_all_tests()

if __name__ == "__main__":
    asyncio.run(main())